{% extends "base.html" %}
{% block content %}
<section class="panel">
  <h2>Providers</h2>
  {% if config.sources %}
  {% for source in config.sources %}
  <div class="source-block">
    <div class="source-header">
      <div>
        <h3>{{ source.name }}</h3>
        <p class="muted">{{ human_source_type(source.type) }} — {{ source.base_url }}</p>
      </div>
      <div class="source-actions">
        <form action="/providers/refresh" method="post" class="refresh-form">
          <input type="hidden" name="name" value="{{ source.name }}" />
          <button type="submit">Refresh list</button>
        </form>
      </div>
    </div>
    {% set source_models = models.get(source.name) %}
    <div class="models-area" data-source-name="{{ source.name }}" data-last-synced="{{ last_synced }}">
      <div class="models-content">
        {% if source_models %}
        <p class="muted">Last fetched at {{ source_models.fetched_at or last_synced }}</p>
        <ul class="model-cards">
          {% for model in source_models.models %}
          <li class="model-card">
            <div class="model-card__header">
              <div>{{ model.id }}</div>
              <div class="model-card__meta">
                {% if model.mode %}
                <span class="badge">Mode: {{ model.mode }}</span>
                {% endif %}
                {% if model.model_type %}
                <span class="badge">Type: {{ model.model_type }}</span>
                {% endif %}
                {% if model.context_window %}
                <span class="badge">Ctx: {{ "{:,}".format(model.context_window) }} tokens</span>
                {% endif %}
                {% if model.max_output_tokens %}
                <span class="badge">Max output: {{ "{:,}".format(model.max_output_tokens) }} tokens</span>
                {% endif %}
                {% if model.capabilities %}
                <span class="badge">Capabilities: {{ model.capabilities | join(", ") }}</span>
                {% endif %}
              </div>
            </div>
            <div class="model-card__body">Metadata fetched from tags.</div>
          </li>
          {% endfor %}
        </ul>
        {% else %}
        <p class="muted">No models fetched yet for this provider.</p>
        {% endif %}
      </div>
    </div>
  </div>
  {% endfor %}
  {% else %}
  <p>No sources configured yet. Add providers in the admin page.</p>
  {% endif %}
</section>
<section class="panel">
  <form action="/sync" method="post">
    <button type="submit">Run sync now</button>
  </form>
</section>
<script>
  const modelsEndpoint = '/models';
  const modelDetailsEndpoint = '/models/show';

  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return null;
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex += 1;
    }
    return `${size.toFixed(size >= 10 || size % 1 === 0 ? 0 : 1)} ${units[unitIndex]}`;
  }

  function buildTagSummary(raw = {}) {
    const details = raw.details || {};
    const modifiedAt = raw.modified_at ? new Date(raw.modified_at).toLocaleString() : null;
    const sizeLabel = formatBytes(raw.size);
    const families = Array.isArray(details.families) && details.families.length
      ? `Familias: ${details.families.join(', ')}`
      : null;

    return [
      details.parameter_size ? `Parámetros: ${details.parameter_size}` : null,
      details.quantization ? `Cuantización: ${details.quantization}` : null,
      sizeLabel ? `Tamaño: ${sizeLabel}` : null,
      modifiedAt ? `Actualizado: ${modifiedAt}` : null,
      families,
      details.family ? `Familia principal: ${details.family}` : null,
      raw.digest ? `Digest: ${raw.digest}` : null,
    ].filter(Boolean);
  }

  // Clean JSON by removing null, empty strings, and empty objects/arrays
  function cleanJSON(obj) {
    if (obj === null || obj === undefined) return null;
    if (typeof obj !== 'object') return obj;

    if (Array.isArray(obj)) {
      const cleaned = obj.map(cleanJSON).filter(item => item !== null);
      return cleaned.length > 0 ? cleaned : null;
    }

    const cleaned = {};
    for (const [key, value] of Object.entries(obj)) {
      const cleanedValue = cleanJSON(value);
      if (cleanedValue !== null && cleanedValue !== '' &&
          !(Array.isArray(cleanedValue) && cleanedValue.length === 0) &&
          !(typeof cleanedValue === 'object' && Object.keys(cleanedValue).length === 0)) {
        cleaned[key] = cleanedValue;
      }
    }

    return Object.keys(cleaned).length > 0 ? cleaned : null;
  }

  function buildLitellmFieldsHTML(litellmModel = {}) {
    if (!litellmModel || Object.keys(litellmModel).length === 0) {
      return '<p class="muted">No se encontraron campos compatibles con LiteLLM.</p>';
    }

    const sections = [];

    // Basic Information Section
    const basicInfo = [];
    if (litellmModel.litellm_provider) {
      basicInfo.push(`<span class="badge badge-provider">Provider: ${litellmModel.litellm_provider}</span>`);
    }
    if (litellmModel.mode) {
      basicInfo.push(`<span class="badge badge-mode">Mode: ${litellmModel.mode}</span>`);
    }
    if (litellmModel.model_type) {
      basicInfo.push(`<span class="badge badge-type">Type: ${litellmModel.model_type}</span>`);
    }
    if (basicInfo.length > 0) {
      sections.push(`<div class="litellm-section"><strong>Información básica:</strong><br>${basicInfo.join(' ')}</div>`);
    }

    // Token Limits Section
    const tokenLimits = [];
    if (litellmModel.max_input_tokens) {
      tokenLimits.push(`<span class="badge">Max Input: ${litellmModel.max_input_tokens.toLocaleString()} tokens</span>`);
    }
    if (litellmModel.max_output_tokens) {
      tokenLimits.push(`<span class="badge">Max Output: ${litellmModel.max_output_tokens.toLocaleString()} tokens</span>`);
    }
    if (litellmModel.max_tokens) {
      tokenLimits.push(`<span class="badge">Max Total: ${litellmModel.max_tokens.toLocaleString()} tokens</span>`);
    }
    if (tokenLimits.length > 0) {
      sections.push(`<div class="litellm-section"><strong>Límites de tokens:</strong><br>${tokenLimits.join(' ')}</div>`);
    }

    // Capabilities/Supports Section
    const supports = [];
    const supportFields = Object.keys(litellmModel).filter(k => k.startsWith('supports_'));
    supportFields.forEach(field => {
      if (litellmModel[field] === true) {
        const label = field.replace('supports_', '').replace(/_/g, ' ');
        supports.push(`<span class="badge badge-support">${label}</span>`);
      }
    });
    if (supports.length > 0) {
      sections.push(`<div class="litellm-section"><strong>Capacidades soportadas:</strong><br>${supports.join(' ')}</div>`);
    }

    // Pricing Section
    const pricing = [];
    if (litellmModel.input_cost_per_token) {
      pricing.push(`<span class="badge badge-price">Input: $${(litellmModel.input_cost_per_token * 1000).toFixed(4)}/1K tokens</span>`);
    }
    if (litellmModel.output_cost_per_token) {
      pricing.push(`<span class="badge badge-price">Output: $${(litellmModel.output_cost_per_token * 1000).toFixed(4)}/1K tokens</span>`);
    }
    if (litellmModel.input_cost_per_second) {
      pricing.push(`<span class="badge badge-price">Audio Input: $${(litellmModel.input_cost_per_second * 60).toFixed(4)}/min</span>`);
    }
    if (litellmModel.output_cost_per_second) {
      pricing.push(`<span class="badge badge-price">Audio Output: $${(litellmModel.output_cost_per_second * 60).toFixed(4)}/min</span>`);
    }
    if (litellmModel.output_cost_per_image) {
      pricing.push(`<span class="badge badge-price">Image: $${litellmModel.output_cost_per_image.toFixed(2)}/image</span>`);
    }
    if (pricing.length > 0) {
      sections.push(`<div class="litellm-section"><strong>Precios (ref. OpenAI):</strong><br>${pricing.join(' ')}</div>`);
    }

    // Supported OpenAI Parameters
    if (Array.isArray(litellmModel.supported_openai_params) && litellmModel.supported_openai_params.length > 0) {
      const params = litellmModel.supported_openai_params.map(p => `<span class="badge badge-param">${p}</span>`).join(' ');
      sections.push(`<div class="litellm-section"><strong>Parámetros OpenAI soportados:</strong><br>${params}</div>`);
    }

    return sections.join('');
  }

  function renderModels(container, sourceModels) {
    const content = container.querySelector('.models-content');
    const lastSynced = container.dataset.lastSynced;

    if (!sourceModels || !Array.isArray(sourceModels.models) || sourceModels.models.length === 0) {
      content.innerHTML = '<p class="muted">No models fetched yet for this provider.</p>';
      return;
    }

    const fetchedAt = sourceModels.fetched_at || lastSynced || '';
    const items = sourceModels.models
      .map((model) => {
        // Quick info badges for header
        const quickBadges = [];
        if (model.mode) quickBadges.push(`<span class="badge">Mode: ${model.mode}</span>`);
        if (model.model_type) quickBadges.push(`<span class="badge">Type: ${model.model_type}</span>`);
        if (model.context_window) quickBadges.push(`<span class="badge">Context: ${model.context_window.toLocaleString()} tokens</span>`);

        const capabilities = Array.isArray(model.capabilities) && model.capabilities.length > 0
          ? model.capabilities.join(', ')
          : 'No capabilities specified';

        return `
          <li class="model-card">
            <div class="model-card__header">
              <div class="model-card__title">${model.id}</div>
              <div class="model-card__meta">${quickBadges.join(' ')}</div>
            </div>
            <div class="model-card__preview">
              <strong>Capacidades:</strong> ${capabilities}
            </div>
            <div class="model-card__actions">
              <button type="button" class="model-more-info" data-source-name="${container.dataset.sourceName}" data-model-id="${model.id}">
                Ver campos para LiteLLM
              </button>
            </div>
            <details class="model-card__details">
              <summary style="display: none;"></summary>
              <div class="model-card__details-content">
                <div class="litellm-fields-preview">Cargando...</div>
                <details class="raw-data-toggle">
                  <summary>Ver datos completos (JSON)</summary>
                  <pre class="raw-data-json"></pre>
                </details>
              </div>
            </details>
          </li>
        `;
      })
      .join('');

    content.innerHTML = `
      <p class="muted">Last fetched at ${fetchedAt}</p>
      <ul class="model-cards">${items}</ul>
    `;

    bindModelDetails(container);
  }

  async function loadModels() {
    try {
      const response = await fetch(modelsEndpoint, { headers: { Accept: 'application/json' } });
      if (!response.ok) return;

      const payload = await response.json();
      document.querySelectorAll('.models-area').forEach((container) => {
        const sourceName = container.dataset.sourceName;
        renderModels(container, payload[sourceName]);
      });
    } catch (error) {
      console.error('Failed loading models', error);
    }
  }

  async function refreshSource(form) {
    const formData = new FormData(form);
    await fetch(form.action, { method: 'POST', body: formData });
    await loadModels();
  }

  function bindModelDetails(container) {
    container.querySelectorAll('.model-more-info').forEach((button) => {
      button.addEventListener('click', async () => {
        const sourceName = button.dataset.sourceName;
        const modelId = button.dataset.modelId;
        const card = button.closest('.model-card');
        const details = card.querySelector('.model-card__details');
        const fieldsPreview = details.querySelector('.litellm-fields-preview');
        const rawDataJson = details.querySelector('.raw-data-json');

        // Toggle details
        const isOpen = details.open;
        if (isOpen) {
          details.open = false;
          button.textContent = 'Ver campos para LiteLLM';
          return;
        }

        details.open = true;
        button.textContent = 'Ocultar campos';
        fieldsPreview.innerHTML = '<p class="muted">Cargando información...</p>';

        try {
          const params = new URLSearchParams({ source: sourceName, model: modelId });
          const response = await fetch(`${modelDetailsEndpoint}?${params.toString()}`, {
            headers: { Accept: 'application/json' },
          });
          if (!response.ok) {
            fieldsPreview.innerHTML = `<p class="error">No se pudo cargar la información (${response.status}).</p>`;
            return;
          }

          const payload = await response.json();
          const litellmModel = payload?.litellm_model || {};
          const rawDetails = payload?.raw || payload || {};

          // Build the LiteLLM fields HTML
          const fieldsHTML = buildLitellmFieldsHTML(litellmModel);
          fieldsPreview.innerHTML = `
            <div class="litellm-import-preview">
              <h4>Campos que se importarán a LiteLLM:</h4>
              ${fieldsHTML}
            </div>
          `;

          // Clean and display JSON data
          const cleanedLitellmModel = cleanJSON(litellmModel);
          const cleanedRawDetails = cleanJSON(rawDetails);

          rawDataJson.textContent = [
            '// Modelo normalizado para LiteLLM (estos campos se sincronizarán):',
            JSON.stringify(cleanedLitellmModel, null, 2),
            '',
            '// Respuesta completa del provider:',
            JSON.stringify(cleanedRawDetails, null, 2),
          ].join('\n');
        } catch (error) {
          console.error('Failed loading model details', error);
          fieldsPreview.innerHTML = '<p class="error">No se pudo cargar la información extendida.</p>';
        }
      });
    });
  }

  document.querySelectorAll('.refresh-form').forEach((form) => {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      await refreshSource(form);
    });
  });

  document.addEventListener('DOMContentLoaded', loadModels);
</script>
{% endblock %}
