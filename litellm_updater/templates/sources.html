{% extends "base.html" %}
{% block content %}
<section class="panel">
  <h2>Sources</h2>
  {% if config.sources %}
  {% for source in config.sources %}
  <div class="source-block">
    <div class="source-header">
      <div>
        <h3>{{ source.name }}</h3>
        <p class="muted">{{ human_source_type(source.type) }} — {{ source.base_url }}</p>
      </div>
      <div class="source-actions">
        <form action="/sources/refresh" method="post" class="refresh-form">
          <input type="hidden" name="name" value="{{ source.name }}" />
          <button type="submit">Refresh list</button>
        </form>
      </div>
    </div>
    {% set source_models = models.get(source.name) %}
    <div class="models-area" data-source-name="{{ source.name }}" data-last-synced="{{ last_synced }}">
      <div class="models-content">
        {% if source_models %}
        <p class="muted">Last fetched at {{ source_models.fetched_at or last_synced }}</p>
        <ul class="model-cards">
          {% for model in source_models.models %}
          {% set litellm_fields = model.litellm_fields %}
          <li class="model-card">
            <!-- Model Header -->
            <div class="model-card__header">
              <div class="model-card__title">{{ model.id }}</div>
              {% if model.raw.get('details') %}
              {% set details = model.raw.details %}
              <div class="model-card__subtitle">
                {% if details.get('family') %}{{ details.family }}{% endif %}
                {% if details.get('parameter_size') %}
                  {% if details.get('family') %} • {% endif %}{{ details.parameter_size }}
                {% endif %}
                {% if details.get('quantization_level') %}
                  {% if details.get('family') or details.get('parameter_size') %} • {% endif %}{{ details.quantization_level }}
                {% endif %}
              </div>
              {% endif %}
            </div>

            <!-- Model Info -->
            <div class="model-card__info">
              <!-- Context Window -->
              {% if model.context_window or litellm_fields.get('max_input_tokens') %}
              <span class="badge">
                Context: {{ "{:,}".format(litellm_fields.get('max_input_tokens', model.context_window)) }}
              </span>
              {% endif %}

              <!-- Capabilities -->
              {% if model.capabilities %}
              {% for capability in model.capabilities[:3] %}
              <span class="badge badge-support">{{ capability }}</span>
              {% endfor %}
              {% if model.capabilities|length > 3 %}
              <span class="badge">+{{ model.capabilities|length - 3 }} más</span>
              {% endif %}
              {% endif %}
            </div>

            <!-- Actions -->
            <div class="model-card__actions">
              <button type="button" class="btn-info model-more-info" data-source-name="{{ source.name }}" data-model-id="{{ model.id }}">
                Info
              </button>
              <button type="button" class="btn-edit model-edit" data-source-name="{{ source.name }}" data-model-id="{{ model.id }}">
                Edit
              </button>
              <button type="button" class="btn-add model-add" data-source-name="{{ source.name }}" data-model-id="{{ model.id }}">
                Add
              </button>
            </div>

            <!-- Details (hidden by default) -->
            <details class="model-card__details" style="grid-column: 1 / -1; margin-top: 0.5rem;">
              <summary style="display: none;"></summary>
              <div class="model-card__details-content">
                <div class="litellm-fields-preview">Cargando información completa...</div>
                <details class="raw-data-toggle">
                  <summary>Ver datos completos (JSON)</summary>
                  <pre class="raw-data-json"></pre>
                </details>
              </div>
            </details>
          </li>
          {% endfor %}
        </ul>
        {% else %}
        <p class="muted">No models fetched yet for this source.</p>
        {% endif %}
      </div>
    </div>
  </div>
  {% endfor %}
  {% else %}
  <p>No sources configured yet. Add sources in the admin page.</p>
  {% endif %}
</section>
<section class="panel">
  <form action="/sync" method="post">
    <button type="submit">Run sync now</button>
  </form>
</section>
<script>
  const modelsEndpoint = '/models';
  const modelDetailsEndpoint = '/models/show';

  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return null;
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex += 1;
    }
    return `${size.toFixed(size >= 10 || size % 1 === 0 ? 0 : 1)} ${units[unitIndex]}`;
  }

  function buildTagSummary(raw = {}) {
    const details = raw.details || {};
    const modifiedAt = raw.modified_at ? new Date(raw.modified_at).toLocaleString() : null;
    const sizeLabel = formatBytes(raw.size);
    const families = Array.isArray(details.families) && details.families.length
      ? `Familias: ${details.families.join(', ')}`
      : null;

    return [
      details.parameter_size ? `Parámetros: ${details.parameter_size}` : null,
      details.quantization ? `Cuantización: ${details.quantization}` : null,
      sizeLabel ? `Tamaño: ${sizeLabel}` : null,
      modifiedAt ? `Actualizado: ${modifiedAt}` : null,
      families,
      details.family ? `Familia principal: ${details.family}` : null,
      raw.digest ? `Digest: ${raw.digest}` : null,
    ].filter(Boolean);
  }

  // Clean JSON by removing null, empty strings, and empty objects/arrays
  function cleanJSON(obj) {
    if (obj === null || obj === undefined) return null;
    if (typeof obj !== 'object') return obj;

    if (Array.isArray(obj)) {
      const cleaned = obj.map(cleanJSON).filter(item => item !== null);
      return cleaned.length > 0 ? cleaned : null;
    }

    const cleaned = {};
    for (const [key, value] of Object.entries(obj)) {
      const cleanedValue = cleanJSON(value);
      if (cleanedValue !== null && cleanedValue !== '' &&
          !(Array.isArray(cleanedValue) && cleanedValue.length === 0) &&
          !(typeof cleanedValue === 'object' && Object.keys(cleanedValue).length === 0)) {
        cleaned[key] = cleanedValue;
      }
    }

    return Object.keys(cleaned).length > 0 ? cleaned : null;
  }

  function buildLitellmFieldsHTML(litellmModel = {}, rawModel = {}) {
    if (!litellmModel || Object.keys(litellmModel).length === 0) {
      return '<p class="muted">No se encontraron campos compatibles con LiteLLM.</p>';
    }

    const sections = [];

    // Parameter Mapping Section (Ollama → OpenAI)
    if (Array.isArray(litellmModel.supported_openai_params) && litellmModel.supported_openai_params.length > 0) {
      const paramMappings = [];
      const ollamaParams = rawModel.parameters || '';

      // Show mapped parameters
      const mappings = {
        'repeat_penalty': 'frequency_penalty',
        'temperature': 'temperature',
        'top_k': 'top_k',
        'top_p': 'top_p',
        'stop': 'stop'
      };

      for (const [ollama, openai] of Object.entries(mappings)) {
        if (ollamaParams.includes(ollama) && litellmModel.supported_openai_params.includes(openai)) {
          paramMappings.push(`
            <div class="param-mapping-item">
              <span class="param-mapping-item__source">${ollama}</span>
              <span class="param-mapping-item__arrow">→</span>
              <span class="param-mapping-item__target">${openai}</span>
            </div>
          `);
        }
      }

      if (paramMappings.length > 0) {
        sections.push(`
          <div class="metadata-section metadata-section--mapping">
            <div class="metadata-section__title">Mapeo Ollama → OpenAI</div>
            <div class="param-mapping">
              ${paramMappings.join('')}
            </div>
            <div class="param-mapping-note">
              Parámetros extraídos desde Ollama y mapeados a formato OpenAI compatible
            </div>
          </div>
        `);
      }

      // Show all supported OpenAI parameters
      const params = litellmModel.supported_openai_params.map(p => `<span class="badge badge-param">${p}</span>`).join(' ');
      sections.push(`
        <div class="metadata-section">
          <div class="metadata-section__title">Todos los parámetros soportados</div>
          ${params}
        </div>
      `);
    }

    // Token Limits Section
    const tokenLimits = [];
    if (litellmModel.max_input_tokens) {
      tokenLimits.push(`
        <div class="token-limit-item">
          <span class="token-limit-item__label">Entrada (Context):</span>
          <span class="token-limit-item__value">${litellmModel.max_input_tokens.toLocaleString()}</span>
        </div>
      `);
    }
    if (litellmModel.max_output_tokens) {
      tokenLimits.push(`
        <div class="token-limit-item">
          <span class="token-limit-item__label">Salida:</span>
          <span class="token-limit-item__value">${litellmModel.max_output_tokens.toLocaleString()}</span>
        </div>
      `);
    }
    if (litellmModel.max_tokens) {
      tokenLimits.push(`
        <div class="token-limit-item">
          <span class="token-limit-item__label">Total:</span>
          <span class="token-limit-item__value">${litellmModel.max_tokens.toLocaleString()}</span>
        </div>
      `);
    }
    if (tokenLimits.length > 0) {
      sections.push(`
        <div class="metadata-section metadata-section--tokens">
          <div class="metadata-section__title">Límites de Tokens</div>
          <div class="token-limits">
            ${tokenLimits.join('')}
          </div>
        </div>
      `);
    }

    // Capabilities/Supports Section
    const supports = [];
    const supportFields = Object.keys(litellmModel).filter(k => k.startsWith('supports_'));
    supportFields.forEach(field => {
      if (litellmModel[field] === true) {
        const label = field.replace('supports_', '').replace(/_/g, ' ');
        supports.push(`<div class="capability-item">${label}</div>`);
      }
    });
    if (supports.length > 0) {
      sections.push(`
        <div class="metadata-section metadata-section--capabilities">
          <div class="metadata-section__title">Capacidades Soportadas</div>
          <div class="capabilities-grid">
            ${supports.join('')}
          </div>
        </div>
      `);
    }

    // Pricing Section
    const pricingItems = [];
    if (litellmModel.input_cost_per_token) {
      pricingItems.push(`
        <div class="pricing-item">
          <span class="pricing-item__label">Entrada:</span>
          <span class="pricing-item__value">$${(litellmModel.input_cost_per_token * 1000).toFixed(4)}/1K tokens</span>
        </div>
      `);
    }
    if (litellmModel.output_cost_per_token) {
      pricingItems.push(`
        <div class="pricing-item">
          <span class="pricing-item__label">Salida:</span>
          <span class="pricing-item__value">$${(litellmModel.output_cost_per_token * 1000).toFixed(4)}/1K tokens</span>
        </div>
      `);
    }
    if (litellmModel.input_cost_per_second) {
      pricingItems.push(`
        <div class="pricing-item">
          <span class="pricing-item__label">Audio Entrada:</span>
          <span class="pricing-item__value">$${(litellmModel.input_cost_per_second * 60).toFixed(4)}/min</span>
        </div>
      `);
    }
    if (litellmModel.output_cost_per_second) {
      pricingItems.push(`
        <div class="pricing-item">
          <span class="pricing-item__label">Audio Salida:</span>
          <span class="pricing-item__value">$${(litellmModel.output_cost_per_second * 60).toFixed(4)}/min</span>
        </div>
      `);
    }
    if (litellmModel.output_cost_per_image) {
      pricingItems.push(`
        <div class="pricing-item">
          <span class="pricing-item__label">Imagen:</span>
          <span class="pricing-item__value">$${litellmModel.output_cost_per_image.toFixed(2)}/imagen</span>
        </div>
      `);
    }
    if (pricingItems.length > 0) {
      sections.push(`
        <div class="metadata-section metadata-section--pricing">
          <div class="metadata-section__title">Precios (ref. OpenAI)</div>
          <div class="pricing-grid">
            ${pricingItems.join('')}
          </div>
        </div>
      `);
    }

    return sections.join('');
  }

  function renderModels(container, sourceModels) {
    const content = container.querySelector('.models-content');
    const lastSynced = container.dataset.lastSynced;

    if (!sourceModels || !Array.isArray(sourceModels.models) || sourceModels.models.length === 0) {
      content.innerHTML = '<p class="muted">No models fetched yet for this source.</p>';
      return;
    }

    const fetchedAt = sourceModels.fetched_at || lastSynced || '';
    const items = sourceModels.models
      .map((model) => {
        // Build subtitle with model details
        const details = model.raw?.details || {};
        const subtitleParts = [];
        if (details.family) subtitleParts.push(details.family);
        if (details.parameter_size) subtitleParts.push(details.parameter_size);
        if (details.quantization_level) subtitleParts.push(details.quantization_level);
        const subtitle = subtitleParts.length > 0 ? `<div class="model-card__subtitle">${subtitleParts.join(' • ')}</div>` : '';

        // Context window badge
        const contextValue = model.max_input_tokens || model.context_window;
        const contextBadge = contextValue
          ? `<span class="badge">Context: ${contextValue.toLocaleString()}</span>`
          : '';

        // Capabilities badges (show first 3)
        const capabilitiesBadges = [];
        if (Array.isArray(model.capabilities) && model.capabilities.length > 0) {
          const capsToShow = model.capabilities.slice(0, 3);
          capsToShow.forEach(cap => {
            capabilitiesBadges.push(`<span class="badge badge-support">${cap}</span>`);
          });
          if (model.capabilities.length > 3) {
            capabilitiesBadges.push(`<span class="badge">+${model.capabilities.length - 3} más</span>`);
          }
        }

        return `
          <li class="model-card">
            <div class="model-card__header">
              <div class="model-card__title">${model.id}</div>
              ${subtitle}
            </div>
            <div class="model-card__info">
              ${contextBadge}
              ${capabilitiesBadges.join('')}
            </div>
            <div class="model-card__actions">
              <button type="button" class="btn-info model-more-info" data-source-name="${container.dataset.sourceName}" data-model-id="${model.id}">
                Info
              </button>
              <button type="button" class="btn-edit model-edit" data-source-name="${container.dataset.sourceName}" data-model-id="${model.id}">
                Edit
              </button>
              <button type="button" class="btn-add model-add" data-source-name="${container.dataset.sourceName}" data-model-id="${model.id}">
                Add
              </button>
            </div>
            <details class="model-card__details" style="grid-column: 1 / -1; margin-top: 0.5rem;">
              <summary style="display: none;"></summary>
              <div class="model-card__details-content">
                <div class="litellm-fields-preview">Cargando información completa...</div>
                <details class="raw-data-toggle">
                  <summary>Ver datos completos (JSON)</summary>
                  <pre class="raw-data-json"></pre>
                </details>
              </div>
            </details>
          </li>
        `;
      })
      .join('');

    content.innerHTML = `
      <p class="muted">Last fetched at ${fetchedAt}</p>
      <ul class="model-cards">${items}</ul>
    `;

    bindModelActions(container);
  }

  async function loadModels() {
    try {
      const response = await fetch(modelsEndpoint, { headers: { Accept: 'application/json' } });
      if (!response.ok) return;

      const payload = await response.json();
      document.querySelectorAll('.models-area').forEach((container) => {
        const sourceName = container.dataset.sourceName;
        renderModels(container, payload[sourceName]);
      });
    } catch (error) {
      console.error('Failed loading models', error);
    }
  }

  async function refreshSource(form) {
    const formData = new FormData(form);
    await fetch(form.action, { method: 'POST', body: formData });
    await loadModels();
  }

  function bindModelActions(container) {
    // Info button (existing functionality)
    container.querySelectorAll('.model-more-info').forEach((button) => {
      button.addEventListener('click', async () => {
        const sourceName = button.dataset.sourceName;
        const modelId = button.dataset.modelId;
        const card = button.closest('.model-card');
        const details = card.querySelector('.model-card__details');
        const fieldsPreview = details.querySelector('.litellm-fields-preview');
        const rawDataJson = details.querySelector('.raw-data-json');

        // Toggle details
        const isOpen = details.open;
        if (isOpen) {
          details.open = false;
          button.textContent = 'Ver más información';
          return;
        }

        details.open = true;
        button.textContent = 'Ocultar información';
        fieldsPreview.innerHTML = '<p class="muted">Cargando información completa...</p>';

        try {
          const params = new URLSearchParams({ source: sourceName, model: modelId });
          const response = await fetch(`${modelDetailsEndpoint}?${params.toString()}`, {
            headers: { Accept: 'application/json' },
          });
          if (!response.ok) {
            fieldsPreview.innerHTML = `<p class="error">No se pudo cargar la información (${response.status}).</p>`;
            return;
          }

          const payload = await response.json();
          const litellmModel = payload?.litellm_model || {};
          const rawDetails = payload?.raw || payload || {};

          // Build the LiteLLM fields HTML
          const fieldsHTML = buildLitellmFieldsHTML(litellmModel, rawDetails);
          fieldsPreview.innerHTML = `
            <div class="litellm-import-preview">
              <h4>Campos que se importarán a LiteLLM:</h4>
              ${fieldsHTML}
            </div>
          `;

          // Clean and display JSON data
          const cleanedLitellmModel = cleanJSON(litellmModel);
          const cleanedRawDetails = cleanJSON(rawDetails);

          rawDataJson.textContent = [
            '// Modelo ya formateado para LiteLLM (campos que se importarán):',
            JSON.stringify(cleanedLitellmModel, null, 2),
            '',
            '// Respuesta completa del source:',
            JSON.stringify(cleanedRawDetails, null, 2),
          ].join('\n');
        } catch (error) {
          console.error('Failed loading model details', error);
          fieldsPreview.innerHTML = '<p class="error">No se pudo cargar la información extendida.</p>';
        }
      });
    });

    // Edit button
    container.querySelectorAll('.model-edit').forEach((button) => {
      button.addEventListener('click', () => {
        const sourceName = button.dataset.sourceName;
        const modelId = button.dataset.modelId;

        // TODO: Implement edit modal/page
        console.log('Edit model:', sourceName, modelId);
        alert(`Editar modelo ${modelId} - Pendiente de implementación`);
      });
    });

    // Add button
    container.querySelectorAll('.model-add').forEach((button) => {
      button.addEventListener('click', async () => {
        const sourceName = button.dataset.sourceName;
        const modelId = button.dataset.modelId;

        if (!confirm(`¿Añadir ${modelId} a LiteLLM?`)) {
          return;
        }

        // TODO: Implement actual add endpoint
        console.log('Add model to LiteLLM:', sourceName, modelId);
        alert(`Añadir ${modelId} a LiteLLM - Pendiente de implementación en el backend`);
      });
    });
  }

  document.querySelectorAll('.refresh-form').forEach((form) => {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      await refreshSource(form);
    });
  });

  document.addEventListener('DOMContentLoaded', loadModels);
  loadModels();
</script>
{% endblock %}
